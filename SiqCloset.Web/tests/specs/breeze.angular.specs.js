ddescribe('Breeze.Angular related tests', function() {
    'use strict';

    var $httpBackend, $rootScope;
    var mgr;
    var serviceName = 'api/mock';
    var serviceNameMatcher = /api\/mock/;

    beforeEach(function () {

        module('breeze.angular');

        inject(function (_$httpBackend_, _$rootScope_, breeze) {
            $httpBackend = _$httpBackend_;
            $rootScope = _$rootScope_;

            var ds = new breeze.DataService({
                serviceName: serviceName,
                hasServerMetadata: false,
            });
            mgr = new breeze.EntityManager({ dataService: ds });
        });
        
    });

    afterEach(function () {
        $httpBackend.verifyNoOutstandingRequest();
    });

    it('should use $httpBackend for any http get', function(done) {
        $httpBackend.whenGET(serviceNameMatcher).respond(200);

        var query = breeze.EntityQuery.from('Fake');
        mgr.executeQuery(query).then(function(results) {
            expect(true).toBe(true);
            done();
        }, function(error) {
            expect(false).toBe(true);
            done();
        });

        $httpBackend.flush();
    });

    it('should mock the results of the http get', function (done) {
        $httpBackend.whenGET(serviceNameMatcher).respond(200, { name: 'denis' });

        var query = breeze.EntityQuery.from('Fake');
        mgr.executeQuery(query).then(function (data) {
            expect(data.results[0].name).toBe('denis');
            done();
        }, function (error) {
            expect(false).toBe(true);
            done();
        });

        $httpBackend.flush();
    });

    //For SO post - http://stackoverflow.com/questions/23597535/breeze-not-populating-entities-from-navigationproperties
    describe('client side metadata for Patient and Prior Study', function () {

        var mgr;
        var addType, helper;
        var serviceName = 'metadataClientSideTest';
        var serviceNameMatcher = /metadataClientSideTest/;
        var priorStudyEntityName = 'PriorStudy';
        var patientEntityName = 'Patient';
        var patientResourceName = 'Patients';
        var priorStudyResourceName = 'PriorStudies';

        var $httpBackend;

        beforeEach(function () {
            //tell Breeze to convert the PascalCase from the server
            //to the camelCase on the client
            breeze.NamingConvention.camelCase.setAsDefault();

            var ds = new breeze.DataService({
                serviceName: serviceName,
                hasServerMetadata: false,
                jsonResultsAdapter: createJsonResultsAdapter(),
            });
            mgr = new breeze.EntityManager({ dataService: ds });
            var store = mgr.metadataStore;
            init(store, serviceName);
            initMetadata();
            createSomeMockData();

            inject(function(_$httpBackend_) {
                $httpBackend = _$httpBackend_;
            });

            // Initialize the metdataFactory with convenience fns and variables 
            function init(metadataStore, _serviceName) {

                var store = metadataStore; // the metadataStore that we'll be filling

                // namespace of the corresponding classes on the server
                var namespace = 'Model'; // don't really need it here 

                // 'Identity' is the default key generation strategy for this app
                var keyGen = breeze.AutoGeneratedKeyType.Identity;

                // Breeze Labs: breeze.metadata.helper.js
                // https://github.com/IdeaBlade/Breeze/blob/master/Breeze.Client/Scripts/Labs/breeze.metadata-helper.js
                // The helper reduces data entry by applying common conventions
                // and converting common abbreviations (e.g., 'type' -> 'dataType')
                helper = new breeze.config.MetadataHelper(namespace, keyGen);
                helper.addDataService(store, _serviceName);

                // addType - make it easy to add the type to the store using the helper
                addType = function (type) { return helper.addTypeToStore(store, type); };
            }

            function initMetadata() {
                helper.addTypeToStore(mgr.metadataStore, {
                    name: priorStudyEntityName,
                    dataProperties: {
                        priorStudyId: { type: breeze.DataType.Int32 },
                        patientId: { type: breeze.DataType.Int32 },
                        priorStudyType: { max: 6 },
                        priorStudyPurpose: { max: 12 },
                        notes: { max: 250 }
                    },

                    navigationProperties: {
                        patient: patientEntityName,
                    }
                });

                helper.addTypeToStore(mgr.metadataStore, {
                    name: patientEntityName,
                    dataProperties: {
                        patientId: { type: breeze.DataType.Int32 },
                        firstName: { max: 25, nameOnServer: 'FirstName' },
                        lastName: { max: 25 },
                    },
                    navigationProperties: {
                        priorStudies: { entityTypeName: priorStudyEntityName, hasMany: true }
                    }
                });
            }

            function createSomeMockData() {
                var patientInits = {
                    patientId: 1,
                    firstName: 'Denis',
                    lastName: 'Koswara',
                };
                var patient = mgr.createEntity(patientEntityName, patientInits);

                var priorStudyInits = {
                    priorStudyId: 2,
                    priorStudyType: 'DK',
                    priorStudyPurpose: 'Testing',
                    notes: 'Do not forget',
                };
                var priorStudy = mgr.createEntity(priorStudyEntityName, priorStudyInits);
                patient.priorStudies.push(priorStudy);
                mgr.attachEntity(patient);
                //mgr.attachEntity(priorStudy);
            }

            function createJsonResultsAdapter() {
                var jsonResultsAdapter = new breeze.JsonResultsAdapter({
                    name: "adapter",
                    visitNode: function (node, mappingContext, nodeContext) {
                        //if node has PatientId and PriorStudy,
                        //then it's a Patient entity type and we need to parse it
                        if (node.PatientId && node.PriorStudy) {
                            node.PriorStudies = node.PriorStudy;
                            return { entityType: patientEntityName };
                        } else {    //it's a PriorStudy type
                            return { entityType: priorStudyEntityName };
                        }
                    }
                });

                return jsonResultsAdapter;
            }
        });

        it('should be defined properly', function () {
            var query = breeze.EntityQuery.from('Patients').toType('Patient');

            var results = mgr.executeQueryLocally(query);
            var patient = results[0];
            var priorStudy = patient.priorStudies[0];

            expect(priorStudy).toBeDefined();
            expect(priorStudy.priorStudyId).toEqual(2);
            expect(priorStudy.priorStudyType).toEqual('DK');
            expect(priorStudy.patient.firstName).toEqual('Denis');

        });

        describe('My custom JsonResultsAdapter for my client side metadata', function() {
            var patient;

            beforeEach(function() {
                var fakeJsonResponse = initFakeServerResponse();

                //Faking the JSON response here
                $httpBackend.whenGET(serviceNameMatcher).respond(200, fakeJsonResponse);

                //This is just a fake query, it can be in any form
                var query = breeze.EntityQuery.from(patientResourceName).expand('priorStudies');

                mgr.executeQuery(query).then(success).catch(fail);

                $httpBackend.flush();

                function success(data) {
                    expect(data.results.length > 0).toBe(true);
                    patient = data.results[0];
                }

                function fail(error) {
                    //should not come here, fail on purpose
                    expect(false).toBe(true);
                    console.log('ERROR: ' + error);
                }
                
                function initFakeServerResponse() {
                    return {
                        FirstName: "Steve",
                        LastName: "Holt",
                        PatientId: 100,
                        PriorStudy: [
                            {
                                PriorStudyId: 100,
                                PriorStudyType: "BLAH",
                                PriorStudyPurpose: "Whatever",
                                PatientId: 100,
                                Notes: "la la la"
                            }
                        ]
                    }
                }

            });


            it('should parse Patient correctly', function () {
                //prove to ourselves that patient is now a Breeze entity
                expect(patient.entityAspect).toBeDefined();
                expect(patient.firstName).toEqual('Steve');
                expect(patient.lastName).toEqual('Holt');
                expect(patient.patientId).toEqual(100);
            });

            it('should parse PriorStudy correctly', function () {
                var priorStudies = patient.priorStudies;
                expect(priorStudies.length > 0).toBe(true);
                var priorStudy = priorStudies[0];

                //prove to ourselves that priorStudy is now also a Breeze entity
                expect(priorStudy.entityAspect).toBeDefined();
                expect(priorStudy.priorStudyId).toEqual(100);
                expect(priorStudy.priorStudyType).toEqual('BLAH');
                expect(priorStudy.priorStudyPurpose).toEqual('Whatever');
                expect(priorStudy.patientId).toEqual(100);
                expect(priorStudy.notes).toEqual('la la la');
            });
        });


    });


})